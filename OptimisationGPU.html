<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Analyse d'Efficacité Énergétique : Métrique ED²</title>
    
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script>
        window.MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\\[', '\\]']]
            }
        };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

    <style>
        :root {
            --primary: #334155; /* Slate 700 - Plus neutre */
            --accent: #10b981;  /* Emerald */
            --secondary: #3b82f6; /* Blue */
            --warning: #f59e0b; /* Amber */
            --danger: #ef4444;  /* Red */
            --bg: #f8fafc;
        }
        body {
            font-family: 'Segoe UI', 'Inter', system-ui, sans-serif;
            line-height: 1.6;
            color: #1e293b;
            background-color: var(--bg);
            margin: 0;
            padding: 20px;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            padding: 40px;
            border-radius: 8px; /* Rayons plus subtils */
            box-shadow: 0 4px 6px -1px rgba(0,0,0,0.1);
            border: 1px solid #e2e8f0;
        }
        h1 { color: var(--primary); font-weight: 700; font-size: 1.8rem; margin-bottom: 1.5rem; }
        h2 { color: var(--primary); margin-top: 40px; border-bottom: 1px solid #e2e8f0; padding-bottom: 10px; font-size: 1.4rem; }
        h3 { color: #475569; font-size: 1.1rem; margin-top: 25px; }
        
        .control-panel {
            background: #f8fafc;
            padding: 20px;
            border: 1px solid #cbd5e1;
            border-radius: 6px;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        .control-group { display: flex; flex-direction: column; }
        label { font-weight: 600; margin-bottom: 5px; font-size: 0.85em; color: #64748b; }
        input { padding: 8px; border: 1px solid #cbd5e1; border-radius: 4px; font-family: monospace; }

        .formula-box {
            background: #fff;
            border: 1px solid #e2e8f0;
            padding: 20px;
            margin: 20px 0;
            border-radius: 6px;
            text-align: center;
        }

        .chart-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 20px;
            margin-top: 30px;
        }
        
        .chart-container { 
            height: 350px; 
            background: #fff; 
            padding: 15px; 
            border: 1px solid #f1f5f9;
            border-radius: 6px;
        }

        .chart-container.square {
            aspect-ratio: 1 / 1;
            height: auto;
            max-width: 450px;
            margin: 0 auto;
        }

        .result-card {
            background: #1e293b;
            color: white;
            padding: 25px;
            border-radius: 6px;
            margin-top: 30px;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }
        @media (max-width: 768px) { .result-card { grid-template-columns: 1fr; } }
        
        .result-card b { color: var(--accent); font-size: 1.2em; }
        .highlight-blue { color: var(--secondary); font-weight: bold; }
        .highlight-gold { color: var(--warning); font-weight: bold; }
        
        .theory-section {
            margin: 20px 0;
            padding: 0 10px;
        }

        .limits-section {
            background: #f1f5f9;
            border-left: 4px solid #64748b;
            padding: 15px 20px;
            margin: 30px 0;
            border-radius: 0 6px 6px 0;
        }

        .references {
            margin-top: 40px;
            padding-top: 20px;
            border-top: 1px solid #e2e8f0;
            font-size: 0.9em;
            color: #64748b;
        }
        .references ul { padding-left: 20px; }
        .references li { margin-bottom: 8px; }

        .notation-list {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 10px;
            margin: 15px 0;
            background: #f8fafc;
            padding: 15px;
            border-radius: 6px;
            font-size: 0.9em;
        }
        .notation-item b { color: var(--primary); font-family: monospace; }
        
        /* Styles spécifiques pour la nouvelle table de presets */
        .preset-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.9rem;
            margin-top: 15px;
        }
        .preset-table th {
            background: #f1f5f9;
            padding: 10px;
            text-align: left;
            border-bottom: 2px solid #cbd5e1;
            color: var(--primary);
        }
        .preset-table td {
            padding: 8px 10px;
            border-bottom: 1px solid #e2e8f0;
        }
        .preset-row:hover {
            background-color: #f8fafc;
            cursor: pointer;
        }
        .preset-row:hover td {
            color: var(--secondary);
            font-weight: 600;
        }
    </style>
</head>
<body>

<div class="container">
    <h1>Analyse d'Efficacité Énergétique : Optimisation du Point de Fonctionnement ($ED^2$)</h1>
    
    <p>Cette étude quantifie le rendement décroissant des architectures GPU modernes à haute fréquence. L'analyse démontre qu'une <b>réduction ciblée de la puissance</b> permet d'atteindre l'optimum d'efficacité architecturale.</p>
    <p>Le modèle met en évidence qu'en acceptant une baisse de performance marginale (typiquement < 7%), le système bénéficie d'une <b>réduction significative de la consommation</b> (~30%) et, par extension, d'une diminution des contraintes thermiques favorisant la durabilité des composants.</p>

    <div class="theory-section">
        <h3>Définitions et Paramètres du Modèle</h3>
        <div class="notation-list">
            <div class="notation-item"><b>$f$</b> : Performance relative (Fréquence normalisée, $f=1.0$ au TDP stock).</div>
            <div class="notation-item"><b>$P$</b> : Puissance totale consommée (Watts).</div>
            <div class="notation-item"><b>$P_{stat}$</b> : Puissance statique (Fuites, VRAM, pertes fixes).</div>
            <div class="notation-item"><b>$n$</b> : Exposant de scaling (Facteur de non-linéarité tension/fréquence).</div>
            <div class="notation-item"><b>$ED^2$</b> : Produit Énergie-Délai carré (Standard VLSI d'efficacité).</div>
        </div>
    </div>

    <!-- NOUVELLE SECTION AJOUTÉE -->
    <div class="theory-section">
        <h3>Profils de Référence (Presets)</h3>
        <p>Cliquez sur un modèle ci-dessous pour charger ses valeurs typiques dans le simulateur :</p>
        <div style="overflow-x: auto;">
            <table class="preset-table">
                <thead>
                    <tr>
                        <th>Modèle / Architecture</th>
                        <th>Puissance Statique ($P_{stat}$)</th>
                        <th>Exposant ($n$)</th>
                        <th>TDP Max ($P_{max}$)</th>
                    </tr>
                </thead>
                <tbody>
                    <tr class="preset-row" onclick="loadPreset(55, 3.6, 450)">
                        <td><b>NVIDIA RTX 4090</b> (Ada Lovelace)</td>
                        <td>55 W</td>
                        <td>3.6</td>
                        <td>450 W</td>
                    </tr>
                    <tr class="preset-row" onclick="loadPreset(48, 3.4, 355)">
                        <td><b>AMD RX 7900 XTX</b> (RDNA 3)</td>
                        <td>48 W</td>
                        <td>3.4</td>
                        <td>355 W</td>
                    </tr>
                    <tr class="preset-row" onclick="loadPreset(40, 3.5, 350)">
                        <td><b>NVIDIA RTX 3090</b> (Ampere - Défaut)</td>
                        <td>40 W</td>
                        <td>3.5</td>
                        <td>350 W</td>
                    </tr>
                    <tr class="preset-row" onclick="loadPreset(20, 3.1, 200)">
                        <td><b>NVIDIA RTX 4070</b> (Ada Lovelace Mid)</td>
                        <td>20 W</td>
                        <td>3.1</td>
                        <td>200 W</td>
                    </tr>
                </tbody>
            </table>
        </div>
        <script>
            function loadPreset(ps, n, pmax) {
                document.getElementById('p_stat').value = ps;
                document.getElementById('n_val').value = n;
                document.getElementById('p_max').value = pmax;
                updateAll(); // Déclenche le recalcul existant
            }
        </script>
    </div>
    <!-- FIN NOUVELLE SECTION -->

    <div class="control-panel">
        <div class="control-group">
            <label>Puissance Statique ($P_{stat}$) [W]</label>
            <input type="number" id="p_stat" value="40" step="1" oninput="updateAll()">
        </div>
        <div class="control-group">
            <label>Exposant de Scaling ($n$)</label>
            <input type="number" id="n_val" value="3.5" step="0.1" oninput="updateAll()">
        </div>
        <div class="control-group">
            <label>TDP Max ($P_{max}$) [W]</label>
            <input type="number" id="p_max" value="350" step="5" oninput="updateAll()">
        </div>
        <div class="control-group">
            <label>Design Life (Standard) [Années]</label>
            <input type="number" id="ref_years" value="5" step="1" oninput="updateAll()">
        </div>
    </div>

    <div class="theory-section">
        <h2>1. Fondements Scientifiques ($ED^2$)</h2>
        <p>Pour optimiser une puce haute performance, on cherche à minimiser le coût énergétique pondéré par le carré du délai (afin de ne pas pénaliser excessivement la performance). Le métrique $ED^2$ se développe ainsi :</p>
        <div class="formula-box">
            $$ED^2 = \text{Énergie} \times \text{Délai}^2 = \left( \frac{P}{f} \right) \cdot \left( \frac{1}{f} \right)^2 = \frac{P_{stat} + k f^n}{f^3}$$
        </div>
        <p>L'optimum est atteint lorsque la dérivée par rapport à $f$ s'annule :</p>
        <div class="formula-box">
            $$\frac{d(ED^2)}{df} = \frac{-3 P_{stat}}{f^4} + (n-3) k f^{n-4} = 0$$
            $$\implies k f^n = \frac{3}{n-3} P_{stat}$$
            $$\mathbf{P_{dyn\_opt} = \frac{3}{n-3} P_{stat}}$$
        </div>
        <p>La puissance totale optimale se déduit alors simplement de la puissance statique :</p>
        <div class="formula-box" style="border: 1px dashed var(--warning); background-color: #fffbeb;">
            $$P_{opt} = P_{stat} + P_{dyn\_opt} = P_{stat} \left( 1 + \frac{3}{n-3} \right)$$
        </div>
        <p>Pour une architecture typique ($n=3.5$), l'optimum mathématique se situe lorsque la puissance dynamique vaut 6 fois la puissance statique, soit bien en deçà du TDP maximal autorisé par le fabricant.</p>
    </div>

    <div class="chart-grid">
        <div class="chart-container">
            <canvas id="powerCurveChart"></canvas>
        </div>
        <div class="chart-container">
            <canvas id="effChart"></canvas>
        </div>
        <div class="chart-container">
            <canvas id="metricChart"></canvas>
        </div>
        <div class="chart-container">
            <canvas id="perfVsPowerChart"></canvas>
        </div>
    </div>

    <div class="theory-section">
        <h2>2. Analyse Coût-Bénéfice (Trade-off)</h2>
        <p>La relation Performance/Puissance étant non-linéaire, le coût énergétique des derniers mégahertz est disproportionné. La courbe de réponse suit la loi :</p>
        <div class="formula-box">
            $$f(P) = \sqrt[n]{\frac{P - P_{stat}}{k}}$$
        </div>
        <p>Le graphique ci-dessous illustre ce rendement décroissant. La zone optimale (points colorés) montre un ratio favorable : l'utilisateur échange une perte de performance minime contre une économie d'énergie substantielle.</p>
        
        <div class="chart-container square">
            <canvas id="savingsChart"></canvas>
        </div>
    </div>

    <div class="theory-section">
        <h2>3. Impact Thermique et Fiabilité (Bénéfice Induit)</h2>
        <p>L'optimisation énergétique n'a pas pour seul but l'économie électrique ; elle agit mécaniquement sur la durabilité du matériel via la réduction du stress thermique.</p>
        <p>Bien que les GPU soient conçus pour fonctionner à leur TDP nominal, l'opération à l'optimum d'efficacité apporte deux avantages passifs majeurs :</p>
        <ol>
            <li><b>Loi d'Arrhenius :</b> La cinétique des réactions de dégradation (électromigration, vieillissement des diélectriques) ralentit exponentiellement avec la baisse de température.</li>
            <li><b>Cycles Thermiques :</b> Une température de fonctionnement plus basse réduit l'amplitude des cycles de dilatation/contraction, préservant les interfaces mécaniques (billes BGA).</li>
        </ol>

        <h3>Modélisation du Gain de Longévité</h3>
        <p>Le modèle thermique simplifie la relation entre la puissance dissipée $P$ et la température de jonction $T_j$ via la résistance thermique globale $R_{th}$ :</p>
        <div class="formula-box">
            $$T_j = T_{amb} + R_{th} \cdot P$$
        </div>
        <p>En utilisant la règle empirique issue de l'équation d'Arrhenius (le taux de défaillance double tous les 10°C), le facteur d'accélération de la durée de vie $AF$ par rapport au fonctionnement à $P_{max}$ s'exprime ainsi :</p>
        <div class="formula-box">
             $$AF = 2^{\frac{T_{max} - T_j}{10}} = 2^{\frac{R_{th}(P_{max} - P)}{10}}$$
        </div>
        <p>Ce facteur traduit directement le gain de longévité théorique affiché ci-dessous.</p>
        
        <div class="chart-container">
            <canvas id="lifespanChart"></canvas>
        </div>
    </div>

    <div class="result-card">
        <div>
            <h3>Optimum de Sobriété ($f/P$)</h3>
            <b><span id="res_power_sobriety">...</span> Watts</b><br>
            <small>f = <span class="highlight-blue" id="res_freq_sobriety">...</span></small>
        </div>
        <div>
            <h3>Optimum de Productivité ($ED^2$)</h3>
            <b><span id="res_power_prod">...</span> Watts</b><br>
            <small>f = <span class="highlight-gold" id="res_freq_prod">...</span></small>
        </div>
    </div>

    <div class="theory-section">
        <h3>Analyse de Positionnement Marché</h3>
        <p>Le réglage d'usine (TDP Max) correspond à une stratégie de maximisation de la performance brute ("Factory Overclocking") nécessaire pour le positionnement concurrentiel dans les benchmarks. L'utilisateur final a l'opportunité de corriger cet arbitrage pour revenir à un point d'équilibre physique plus rationnel.</p>
    </div>

    <div class="limits-section">
        <h3>Limites et Simplifications du Modèle</h3>
        <p>Ce simulateur propose une approche de premier ordre pour guider la décision. Pour une rigueur totale, il convient de noter les simplifications suivantes :</p>
        <ul style="list-style-type: square; padding-left: 20px; color: #334155;">
            <li><b>L'approximation de la Loi de Puissance ($P \propto f^n$) :</b> Nous utilisons un exposant fixe ($n \approx 3.5$). En réalité, cette valeur évolue selon la tension appliquée et la charge spécifique (calcul pur vs accès mémoire).</li>
            <li><b>La variabilité du Silicium ("Silicon Lottery") :</b> Chaque puce est unique. Deux GPU identiques peuvent nécessiter des tensions différentes pour la même fréquence, faisant varier $n$ typiquement entre 3.2 et 4.0.</li>
            <li><b>Dépendance Thermique de $P_{stat}$ :</b> Le modèle considère la puissance statique comme constante. En physique réelle, les courants de fuite augmentent avec la température. Le modèle sous-estime donc légèrement la consommation totale à très haute température (>80°C).</li>
        </ul>
    </div>

    <div class="references">
        <h3>Références</h3>
        <ul>
            <li><b>JEDEC JESD47.</b> "Stress-Test-Driven Qualification of Integrated Circuits". (Standard définissant les modèles de stress thermique et tension pour la qualification des puces).</li>
            <li><b>IPC-9592B.</b> "Requirements for Power Conversion Devices for the Computer and Telecommunications Industries". (Définit les cibles de fiabilité et de durée de vie pour les composants de puissance).</li>
            <li><b>Black, J. R. (1969).</b> "Electromigration—A brief survey and some recent results". IEEE Transactions on Electron Devices.</li>
            <li><b>Gonzalez, R., & Horowitz, M. A. (1996).</b> "Energy-delay efficiency of CMOS processors". IEEE Journal of Solid-State Circuits.</li>
            <li><b>T.J. Nelson (2012).</b> "Component Reliability and MTBF". Semiconductor Reliability News.</li>
        </ul>
    </div>
</div>

<script>
    let powerCurveChart, effChart, metricChart, perfVsPowerChart, savingsChart, lifespanChart;

    const coordPlugin = {
        id: 'coordPlugin',
        afterDatasetsDraw(chart, args, options) {
            const {ctx, data, chartArea: {top, bottom, left, right}, scales: {x, y}} = chart;
            ctx.save();
            
            data.datasets.forEach((dataset, i) => {
                // Seulement si le dataset est marqué comme Optimum et contient des données
                if (dataset.label && dataset.label.includes('Optimum') && dataset.data) {
                    dataset.data.forEach((value, index) => {
                        if (value !== null) {
                            const xVal = data.labels[index];
                            const xPos = x.getPixelForValue(xVal);
                            const yPos = y.getPixelForValue(value);
                            const isSobriety = dataset.label.includes('Sobriété');
                            
                            ctx.beginPath();
                            ctx.arc(xPos, yPos, 4, 0, Math.PI * 2);
                            ctx.fillStyle = dataset.backgroundColor || dataset.borderColor;
                            ctx.fill();
                            ctx.strokeStyle = "white";
                            ctx.lineWidth = 2;
                            ctx.stroke();
                            
                            ctx.font = '600 11px Inter, sans-serif';
                            ctx.textAlign = 'center';
                            
                            const ps = parseFloat(document.getElementById('p_stat').value);
                            const n = parseFloat(document.getElementById('n_val').value);
                            const pmax = parseFloat(document.getElementById('p_max').value);
                            
                            let p_real;
                            // Calculs contextuels pour l'affichage des tooltips
                            if (chart.canvas.id === 'perfVsPowerChart' || chart.canvas.id === 'lifespanChart') {
                                p_real = Math.round(parseFloat(xVal));
                            } else if (chart.canvas.id === 'savingsChart') {
                                const dropPerf = parseFloat(xVal);
                                const f_val = 1 - (dropPerf/100);
                                p_real = Math.round(ps + (pmax - ps) * Math.pow(f_val, n));
                            } else {
                                const f_val = parseFloat(xVal);
                                p_real = Math.round(ps + (pmax - ps) * Math.pow(f_val, n));
                            }
                            
                            const yOffset = isSobriety ? -20 : 25;
                            let txt = `${p_real}W`;
                            
                            if (chart.canvas.id === 'savingsChart') {
                                txt = `-${Math.round(100 - (p_real/pmax*100))}% W`;
                            } else if (chart.canvas.id === 'lifespanChart') {
                                txt = `+${Math.round(value)}% Vie`;
                            }
                            
                            const width = ctx.measureText(txt).width + 10;
                            ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
                            ctx.fillRect(xPos - width/2, yPos + yOffset - 11, width, 14);
                            
                            ctx.fillStyle = isSobriety ? '#059669' : '#d97706';
                            ctx.fillText(txt, xPos, yPos + yOffset);
                        }
                    });
                }
            });
            ctx.restore();
        }
    };

    Chart.register(coordPlugin);

    function updateAll() {
        const ps = parseFloat(document.getElementById('p_stat').value);
        const n = parseFloat(document.getElementById('n_val').value);
        const pmax = parseFloat(document.getElementById('p_max').value);
        const refY = parseFloat(document.getElementById('ref_years').value);
        const k = pmax - ps;

        // Calcul des points optimaux
        const p_tot_sobriety = ps * n / (n - 1);
        const f_sobriety = Math.pow(ps / (k * (n - 1)), 1/n);

        const p_tot_prod = ps + (3 / (n - 3)) * ps;
        const f_prod = Math.pow((3 * ps) / (k * (n - 3)), 1/n);

        document.getElementById('res_power_sobriety').innerText = Math.round(p_tot_sobriety);
        document.getElementById('res_freq_sobriety').innerText = f_sobriety.toFixed(3);
        document.getElementById('res_power_prod').innerText = Math.round(p_tot_prod);
        document.getElementById('res_freq_prod').innerText = f_prod.toFixed(3);

        // Génération des données
        const labelsF = [];
        const p_data = [];
        const eff_data = [];
        const ed2_data = [];
        for (let f = 0.3; f <= 1.2; f += 0.02) {
            const p = ps + k * Math.pow(f, n);
            labelsF.push(f.toFixed(2));
            p_data.push(p);
            eff_data.push(f / p);
            ed2_data.push(p / Math.pow(f, 3));
        }

        const labelsP = [];
        const perf_data = [];
        const life_pct_data = [];
        const t_amb = 30; 
        const t_stock = 80; 
        const r_th = (t_stock - t_amb) / pmax; 

        for (let p = ps + 5; p <= pmax + 50; p += 5) {
            labelsP.push(p.toFixed(0));
            perf_data.push(Math.pow((p - ps) / k, 1/n));
            const t_actual = t_amb + r_th * p;
            const lifespan_ratio = Math.pow(2, (t_stock - t_actual) / 10);
            life_pct_data.push((lifespan_ratio - 1) * 100);
        }

        const labelsDrop = [];
        const savings_data = [];
        const identity_line = [];
        for (let dropPerf = 0; dropPerf <= 40; dropPerf += 2) {
            labelsDrop.push(dropPerf.toFixed(0));
            const currentF = 1 - (dropPerf / 100);
            const currentP = ps + k * Math.pow(currentF, n);
            savings_data.push((1 - (currentP / pmax)) * 100);
            identity_line.push(dropPerf);
        }

        renderCharts(labelsF, p_data, eff_data, ed2_data, f_sobriety, f_prod, labelsP, perf_data, p_tot_sobriety, p_tot_prod, labelsDrop, savings_data, identity_line, life_pct_data, refY);
    }

    function renderCharts(labelsF, p_curve, eff, ed2, f_sob, f_prod, labelsP, perf, p_sob, p_prod, labelsDrop, savings, identity, life_pct, refY) {
        if (powerCurveChart) powerCurveChart.destroy();
        if (effChart) effChart.destroy();
        if (metricChart) metricChart.destroy();
        if (perfVsPowerChart) perfVsPowerChart.destroy();
        if (savingsChart) savingsChart.destroy();
        if (lifespanChart) lifespanChart.destroy();

        const commonOptions = {
            responsive: true,
            maintainAspectRatio: false,
            plugins: { legend: { position: 'top', labels: { boxWidth: 10, usePointStyle: true } } },
            elements: { point: { radius: 0, hitRadius: 10 } }
        };

        const pmax = parseFloat(document.getElementById('p_max').value);

        powerCurveChart = new Chart(document.getElementById('powerCurveChart'), {
            type: 'line',
            data: {
                labels: labelsF,
                datasets: [
                    { label: 'Puissance (Watts)', data: p_curve, borderColor: '#3b82f6', borderWidth: 2 },
                    { label: 'Optimum Sobriété', data: labelsF.map(l => Math.abs(parseFloat(l) - f_sob) < 0.015 ? (p_sob) : null), backgroundColor: '#10b981', showLine: false },
                    { label: 'Optimum Productivité', data: labelsF.map(l => Math.abs(parseFloat(l) - f_prod) < 0.015 ? (p_prod) : null), backgroundColor: '#f59e0b', showLine: false }
                ]
            },
            options: { ...commonOptions, scales: { x: { title: { display: true, text: 'Fréquence Relative (f)' } }, y: { title: { display: true, text: 'Consommation (W)' } } } }
        });

        effChart = new Chart(document.getElementById('effChart'), {
            type: 'line',
            data: {
                labels: labelsF,
                datasets: [
                    { label: 'Efficacité (Perf/Watt)', data: eff, borderColor: '#10b981', borderWidth: 2 },
                    { label: 'Optimum Sobriété', data: labelsF.map(l => Math.abs(parseFloat(l) - f_sob) < 0.015 ? (f_sob/(p_sob)) : null), backgroundColor: '#10b981', showLine: false },
                    { label: 'Optimum Productivité', data: labelsF.map(l => Math.abs(parseFloat(l) - f_prod) < 0.015 ? (f_prod/(p_prod)) : null), backgroundColor: '#f59e0b', showLine: false }
                ]
            },
            options: { 
                ...commonOptions, 
                layout: { padding: { top: 30 } }, // AJOUT: Marge pour éviter le masquage de la légende
                scales: { x: { title: { display: true, text: 'Fréquence Relative (f)' } }, y: { title: { display: true, text: 'Unités Calcul / Joule' } } } 
            }
        });

        metricChart = new Chart(document.getElementById('metricChart'), {
            type: 'line',
            data: {
                labels: labelsF,
                datasets: [
                    { label: 'Coût ED² (à minimiser)', data: ed2, borderColor: '#f59e0b', borderWidth: 2 },
                    { label: 'Optimum Sobriété', data: labelsF.map(l => Math.abs(parseFloat(l) - f_sob) < 0.015 ? (p_sob/Math.pow(f_sob,3)) : null), backgroundColor: '#10b981', showLine: false },
                    { label: 'Optimum Productivité', data: labelsF.map(l => Math.abs(parseFloat(l) - f_prod) < 0.015 ? (p_prod/Math.pow(f_prod,3)) : null), backgroundColor: '#f59e0b', showLine: false }
                ]
            },
            options: { ...commonOptions, scales: { x: { title: { display: true, text: 'Fréquence Relative (f)' } }, y: { title: { display: true, text: 'Indice de Coût' }, min: Math.min(...ed2) * 0.9 } } }
        });

        perfVsPowerChart = new Chart(document.getElementById('perfVsPowerChart'), {
            type: 'line',
            data: {
                labels: labelsP,
                datasets: [
                    { label: 'Performance f(P)', data: perf, borderColor: '#8b5cf6', borderWidth: 2 },
                    { label: 'Optimum Sobriété', data: labelsP.map(l => Math.abs(parseFloat(l) - p_sob) < 3.0 ? f_sob : null), backgroundColor: '#10b981', showLine: false },
                    { label: 'Optimum Productivité', data: labelsP.map(l => Math.abs(parseFloat(l) - p_prod) < 3.0 ? f_prod : null), backgroundColor: '#f59e0b', showLine: false }
                ]
            },
            options: { ...commonOptions, scales: { x: { title: { display: true, text: 'Puissance Limite (W)' } }, y: { title: { display: true, text: 'Performance (f)' } } } }
        });

        lifespanChart = new Chart(document.getElementById('lifespanChart'), {
            type: 'line',
            data: {
                labels: labelsP,
                datasets: [
                    { 
                        label: `Standard Industrie`, 
                        data: labelsP.map(() => 0), 
                        borderColor: '#94a3b8', 
                        borderWidth: 1.5, 
                        borderDash: [5, 5], 
                        fill: false 
                    },
                    { label: 'Gain Longévité (%)', data: life_pct, borderColor: '#ec4899', borderWidth: 2, fill: true, backgroundColor: 'rgba(236, 72, 153, 0.05)' },
                    // SUPPRESSION: Optimum Sobriété retiré de ce graphe car hors échelle pertinente
                    { label: 'Optimum Productivité', data: labelsP.map(l => Math.abs(parseFloat(l) - p_prod) < 3.0 ? life_pct[labelsP.indexOf(l)] : null), backgroundColor: '#f59e0b', showLine: false }
                ]
            },
            options: { 
                ...commonOptions, 
                scales: { 
                    x: { title: { display: true, text: 'Puissance (W)' }, min: 45, max: 390 }, // AJOUT: Min 200W
                    y: { title: { display: true, text: 'Gain Théorique Longévité (%)' }, min: -30, max: 140 } 
                } 
            }
        });

        savingsChart = new Chart(document.getElementById('savingsChart'), {
            type: 'line',
            data: {
                labels: labelsDrop,
                datasets: [
                    { label: 'Économie Réelle', data: savings, borderColor: '#ef4444', borderWidth: 2 },
                    { label: 'Échange Neutre (1 pour 1)', data: identity, borderColor: '#94a3b8', borderWidth: 1, borderDash: [5, 5] },
                    // SUPPRESSION: Optimum Sobriété retiré de ce graphe car illisible à cette échelle
                    { label: 'Optimum Productivité', data: labelsDrop.map(l => Math.abs(parseFloat(l) - (100-f_prod*100)) < 1.1 ? (1 - p_prod/pmax)*100 : null), backgroundColor: '#f59e0b', showLine: false }
                ]
            },
            options: { 
                responsive: true,
                maintainAspectRatio: true,
                aspectRatio: 1,
                plugins: { legend: { position: 'top' } },
                scales: { 
                    x: { title: { display: true, text: 'Baisse de Performance (%)' }, min: 0, max: 40 },
                    y: { title: { display: true, text: 'Économie d\'Énergie (%)' }, min: 0, max: 50 } 
                } 
            }
        });
    }

    window.onload = updateAll;
</script>

</body>
</html>